// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: executions.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/guregu/null/null"
)

const createExecution = `-- name: CreateExecution :one
INSERT INTO executions (
    job_id,
    status
) VALUES (
    $1, $2
) RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type CreateExecutionParams struct {
	JobID  uuid.UUID       `json:"job_id"`
	Status ExecutionStatus `json:"status"`
}

func (q *Queries) CreateExecution(ctx context.Context, arg CreateExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, createExecution, arg.JobID, arg.Status)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExecution = `-- name: DeleteExecution :exec
DELETE FROM executions 
WHERE id = $1
`

func (q *Queries) DeleteExecution(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteExecution, id)
	return err
}

const getExecution = `-- name: GetExecution :one
SELECT id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at FROM executions 
WHERE id = $1
`

func (q *Queries) GetExecution(ctx context.Context, id uuid.UUID) (Execution, error) {
	row := q.db.QueryRow(ctx, getExecution, id)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const getExecutionStats = `-- name: GetExecutionStats :one
SELECT 
    COUNT(*) as total_executions,
    COUNT(*) FILTER (WHERE status = 'completed_success') as successful_executions,
    COUNT(*) FILTER (WHERE status = 'completed_error') as failed_executions,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_executions,
    COUNT(*) FILTER (WHERE status = 'running') as running_executions,
    AVG(cost_actual_usd) as avg_cost,
    SUM(carbon_emitted_kg) as total_carbon
FROM executions 
WHERE job_id = $1
`

type GetExecutionStatsRow struct {
	TotalExecutions      int64   `json:"total_executions"`
	SuccessfulExecutions int64   `json:"successful_executions"`
	FailedExecutions     int64   `json:"failed_executions"`
	PendingExecutions    int64   `json:"pending_executions"`
	RunningExecutions    int64   `json:"running_executions"`
	AvgCost              float64 `json:"avg_cost"`
	TotalCarbon          int64   `json:"total_carbon"`
}

func (q *Queries) GetExecutionStats(ctx context.Context, jobID uuid.UUID) (GetExecutionStatsRow, error) {
	row := q.db.QueryRow(ctx, getExecutionStats, jobID)
	var i GetExecutionStatsRow
	err := row.Scan(
		&i.TotalExecutions,
		&i.SuccessfulExecutions,
		&i.FailedExecutions,
		&i.PendingExecutions,
		&i.RunningExecutions,
		&i.AvgCost,
		&i.TotalCarbon,
	)
	return i, err
}

const getExecutionsByJobID = `-- name: GetExecutionsByJobID :many
SELECT id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at FROM executions 
WHERE job_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetExecutionsByJobID(ctx context.Context, jobID uuid.UUID) ([]Execution, error) {
	rows, err := q.db.Query(ctx, getExecutionsByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ChosenAt,
			&i.CloudRegion,
			&i.VmType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ExitCode,
			&i.LogUri,
			&i.CostEstimateUsd,
			&i.CostActualUsd,
			&i.CarbonIntensityGKwh,
			&i.CarbonEmittedKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionsByJobIDWithLimit = `-- name: GetExecutionsByJobIDWithLimit :many
SELECT id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at FROM executions 
WHERE job_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetExecutionsByJobIDWithLimitParams struct {
	JobID  uuid.UUID `json:"job_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetExecutionsByJobIDWithLimit(ctx context.Context, arg GetExecutionsByJobIDWithLimitParams) ([]Execution, error) {
	rows, err := q.db.Query(ctx, getExecutionsByJobIDWithLimit, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ChosenAt,
			&i.CloudRegion,
			&i.VmType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ExitCode,
			&i.LogUri,
			&i.CostEstimateUsd,
			&i.CostActualUsd,
			&i.CarbonIntensityGKwh,
			&i.CarbonEmittedKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExecutionsByStatus = `-- name: GetExecutionsByStatus :many
SELECT id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at FROM executions 
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) GetExecutionsByStatus(ctx context.Context, status ExecutionStatus) ([]Execution, error) {
	rows, err := q.db.Query(ctx, getExecutionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ChosenAt,
			&i.CloudRegion,
			&i.VmType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ExitCode,
			&i.LogUri,
			&i.CostEstimateUsd,
			&i.CostActualUsd,
			&i.CarbonIntensityGKwh,
			&i.CarbonEmittedKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingExecutions = `-- name: GetPendingExecutions :many
SELECT id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at FROM executions 
WHERE status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingExecutions(ctx context.Context) ([]Execution, error) {
	rows, err := q.db.Query(ctx, getPendingExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.ChosenAt,
			&i.CloudRegion,
			&i.VmType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ExitCode,
			&i.LogUri,
			&i.CostEstimateUsd,
			&i.CostActualUsd,
			&i.CarbonIntensityGKwh,
			&i.CarbonEmittedKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserExecutionStats = `-- name: GetUserExecutionStats :one
SELECT 
    COUNT(*) as total_executions,
    COUNT(*) FILTER (WHERE status = 'completed_success') as successful_executions,
    COUNT(*) FILTER (WHERE status = 'completed_error') as failed_executions,
    AVG(cost_actual_usd) as avg_cost,
    SUM(cost_actual_usd) as total_cost,
    SUM(carbon_emitted_kg) as total_carbon
FROM executions e
JOIN jobs j ON e.job_id = j.id
WHERE j.owner_id = $1
`

type GetUserExecutionStatsRow struct {
	TotalExecutions      int64   `json:"total_executions"`
	SuccessfulExecutions int64   `json:"successful_executions"`
	FailedExecutions     int64   `json:"failed_executions"`
	AvgCost              float64 `json:"avg_cost"`
	TotalCost            int64   `json:"total_cost"`
	TotalCarbon          int64   `json:"total_carbon"`
}

func (q *Queries) GetUserExecutionStats(ctx context.Context, ownerID uuid.UUID) (GetUserExecutionStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserExecutionStats, ownerID)
	var i GetUserExecutionStatsRow
	err := row.Scan(
		&i.TotalExecutions,
		&i.SuccessfulExecutions,
		&i.FailedExecutions,
		&i.AvgCost,
		&i.TotalCost,
		&i.TotalCarbon,
	)
	return i, err
}

const updateExecutionComplete = `-- name: UpdateExecutionComplete :one
UPDATE executions 
SET 
    status = $2,
    completed_at = $3,
    exit_code = $4,
    log_uri = $5,
    cost_actual_usd = $6,
    carbon_emitted_kg = $7
WHERE id = $1
RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type UpdateExecutionCompleteParams struct {
	ID              uuid.UUID       `json:"id"`
	Status          ExecutionStatus `json:"status"`
	CompletedAt     null.Time       `json:"completed_at"`
	ExitCode        null.Int        `json:"exit_code"`
	LogUri          *string         `json:"log_uri"`
	CostActualUsd   null.Float      `json:"cost_actual_usd"`
	CarbonEmittedKg null.Float      `json:"carbon_emitted_kg"`
}

func (q *Queries) UpdateExecutionComplete(ctx context.Context, arg UpdateExecutionCompleteParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionComplete,
		arg.ID,
		arg.Status,
		arg.CompletedAt,
		arg.ExitCode,
		arg.LogUri,
		arg.CostActualUsd,
		arg.CarbonEmittedKg,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const updateExecutionCostEstimate = `-- name: UpdateExecutionCostEstimate :one
UPDATE executions 
SET 
    cost_estimate_usd = $2,
    carbon_intensity_g_kwh = $3
WHERE id = $1
RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type UpdateExecutionCostEstimateParams struct {
	ID                  uuid.UUID  `json:"id"`
	CostEstimateUsd     null.Float `json:"cost_estimate_usd"`
	CarbonIntensityGKwh null.Float `json:"carbon_intensity_g_kwh"`
}

func (q *Queries) UpdateExecutionCostEstimate(ctx context.Context, arg UpdateExecutionCostEstimateParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionCostEstimate, arg.ID, arg.CostEstimateUsd, arg.CarbonIntensityGKwh)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const updateExecutionScheduling = `-- name: UpdateExecutionScheduling :one
UPDATE executions 
SET 
    status = $2,
    chosen_at = $3,
    cloud_region = $4,
    vm_type = $5
WHERE id = $1
RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type UpdateExecutionSchedulingParams struct {
	ID          uuid.UUID       `json:"id"`
	Status      ExecutionStatus `json:"status"`
	ChosenAt    null.Time       `json:"chosen_at"`
	CloudRegion *string         `json:"cloud_region"`
	VmType      *string         `json:"vm_type"`
}

func (q *Queries) UpdateExecutionScheduling(ctx context.Context, arg UpdateExecutionSchedulingParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionScheduling,
		arg.ID,
		arg.Status,
		arg.ChosenAt,
		arg.CloudRegion,
		arg.VmType,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const updateExecutionStart = `-- name: UpdateExecutionStart :one
UPDATE executions 
SET 
    status = 'running',
    started_at = $2
WHERE id = $1
RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type UpdateExecutionStartParams struct {
	ID        uuid.UUID `json:"id"`
	StartedAt null.Time `json:"started_at"`
}

func (q *Queries) UpdateExecutionStart(ctx context.Context, arg UpdateExecutionStartParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionStart, arg.ID, arg.StartedAt)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}

const updateExecutionStatus = `-- name: UpdateExecutionStatus :one
UPDATE executions 
SET status = $2
WHERE id = $1
RETURNING id, job_id, status, chosen_at, cloud_region, vm_type, started_at, completed_at, exit_code, log_uri, cost_estimate_usd, cost_actual_usd, carbon_intensity_g_kwh, carbon_emitted_kg, created_at
`

type UpdateExecutionStatusParams struct {
	ID     uuid.UUID       `json:"id"`
	Status ExecutionStatus `json:"status"`
}

func (q *Queries) UpdateExecutionStatus(ctx context.Context, arg UpdateExecutionStatusParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionStatus, arg.ID, arg.Status)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.ChosenAt,
		&i.CloudRegion,
		&i.VmType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ExitCode,
		&i.LogUri,
		&i.CostEstimateUsd,
		&i.CostActualUsd,
		&i.CarbonIntensityGKwh,
		&i.CarbonEmittedKg,
		&i.CreatedAt,
	)
	return i, err
}
