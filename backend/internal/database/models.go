// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package database

import (
	"database/sql/driver"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/guregu/null/v6"
	"github.com/jackc/pgx/v5/pgtype"
)

// Possible states of job executions
type ExecutionStatus string

const (
	ExecutionStatusPending          ExecutionStatus = "pending"
	ExecutionStatusEvaluating       ExecutionStatus = "evaluating"
	ExecutionStatusRunning          ExecutionStatus = "running"
	ExecutionStatusCompletedSuccess ExecutionStatus = "completed_success"
	ExecutionStatusCompletedError   ExecutionStatus = "completed_error"
	ExecutionStatusOrphaned         ExecutionStatus = "orphaned"
)

func (e *ExecutionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ExecutionStatus(s)
	case string:
		*e = ExecutionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ExecutionStatus: %T", src)
	}
	return nil
}

type NullExecutionStatus struct {
	ExecutionStatus ExecutionStatus `json:"execution_status"`
	Valid           bool            `json:"valid"` // Valid is true if ExecutionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullExecutionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ExecutionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ExecutionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullExecutionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ExecutionStatus), nil
}

func (e ExecutionStatus) Valid() bool {
	switch e {
	case ExecutionStatusPending,
		ExecutionStatusEvaluating,
		ExecutionStatusRunning,
		ExecutionStatusCompletedSuccess,
		ExecutionStatusCompletedError,
		ExecutionStatusOrphaned:
		return true
	}
	return false
}

func AllExecutionStatusValues() []ExecutionStatus {
	return []ExecutionStatus{
		ExecutionStatusPending,
		ExecutionStatusEvaluating,
		ExecutionStatusRunning,
		ExecutionStatusCompletedSuccess,
		ExecutionStatusCompletedError,
		ExecutionStatusOrphaned,
	}
}

// Execution history and metrics for job runs
type Execution struct {
	// Unique execution identifier
	ID uuid.UUID `json:"id"`
	// Reference to the job being executed
	JobID uuid.UUID `json:"job_id"`
	// Current execution status
	Status ExecutionStatus `json:"status"`
	// When scheduler selected this execution
	ChosenAt null.Time `json:"chosen_at"`
	// Cloud region where execution ran
	CloudRegion *string `json:"cloud_region"`
	// Type of VM used for execution
	VmType *string `json:"vm_type"`
	// When container started executing
	StartedAt null.Time `json:"started_at"`
	// When container finished executing
	CompletedAt null.Time `json:"completed_at"`
	// Container exit code (0 = success)
	ExitCode null.Int `json:"exit_code"`
	// URI to execution logs in object storage
	LogUri *string `json:"log_uri"`
	// Estimated cost before execution
	CostEstimateUsd null.Float `json:"cost_estimate_usd"`
	// Actual cost after execution
	CostActualUsd null.Float `json:"cost_actual_usd"`
	// Carbon intensity at execution time (g CO2/kWh)
	CarbonIntensityGKwh null.Float `json:"carbon_intensity_g_kwh"`
	// Total carbon emissions (kg CO2)
	CarbonEmittedKg null.Float `json:"carbon_emitted_kg"`
	CreatedAt       time.Time  `json:"created_at"`
}

// Job definitions and configurations
type Job struct {
	// Unique job identifier
	ID uuid.UUID `json:"id"`
	// Reference to the user who owns this job
	OwnerID uuid.UUID `json:"owner_id"`
	// Container image URI to execute
	ImageUri string `json:"image_uri"`
	// Environment variables as JSON object
	EnvVars []byte `json:"env_vars"`
	// Maximum acceptable delay (0-168 hours = 1 week)
	DelayToleranceHours int32 `json:"delay_tolerance_hours"`
	// Job creation timestamp
	CreatedAt time.Time `json:"created_at"`
	// Last job update timestamp
	UpdatedAt time.Time `json:"updated_at"`
}

// Stores refresh tokens for JWT authentication
type RefreshToken struct {
	// Unique refresh token identifier
	ID uuid.UUID `json:"id"`
	// Reference to users table
	UserID uuid.UUID `json:"user_id"`
	// SHA-256 hash of the refresh token
	TokenHash string `json:"token_hash"`
	// When this refresh token expires
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	// When this refresh token was created
	CreatedAt time.Time `json:"created_at"`
	// When this refresh token was last used
	LastUsed pgtype.Timestamptz `json:"last_used"`
	// Whether this refresh token has been revoked
	IsRevoked bool `json:"is_revoked"`
	// User agent of the client that created this token
	UserAgent *string `json:"user_agent"`
	// IP address of the client that created this token
	IpAddress *netip.Addr `json:"ip_address"`
}

// Stores basic user account information
type User struct {
	// Unique user identifier using UUID
	ID uuid.UUID `json:"id"`
	// User email with format validation
	Email string `json:"email"`
	// Securely hashed password (bcrypt/argon2)
	HashedPassword string `json:"hashed_password"`
	// Account creation timestamp
	CreatedAt time.Time `json:"created_at"`
	// Last account update timestamp
	UpdatedAt time.Time `json:"updated_at"`
	// Whether the user has verified their email address
	EmailVerified bool `json:"email_verified"`
	// Timestamp of the user's last successful login
	LastLogin pgtype.Timestamptz `json:"last_login"`
	// Whether the user account is active (not suspended/disabled)
	IsActive bool `json:"is_active"`
}

// User optimization preferences and weights
type UserSetting struct {
	// Reference to users table (one-to-one)
	UserID uuid.UUID `json:"user_id"`
	// Weight for cost optimization (0.00-1.00)
	CostWeight pgtype.Numeric `json:"cost_weight"`
	// Weight for carbon optimization (0.00-1.00)
	CarbonWeight pgtype.Numeric `json:"carbon_weight"`
	// Last settings update timestamp
	UpdatedAt time.Time `json:"updated_at"`
}
